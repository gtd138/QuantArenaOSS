<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ† AIé‡åŒ–ç«æŠ€åœº</title>
    <link rel="icon" href="data:,">
    
    <!-- ECharts -->
    <script src="echarts.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="tailwindcss-play.js"></script>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .model-card {
            border-left: 4px solid;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }
        .model-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .right-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 450px;
            height: 100vh;
            background: white;
            border-left: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
        }
        .right-panel::-webkit-scrollbar {
            display: none;
        }
        .main-content {
            margin-right: 450px;
        }
        .log-entry {
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.5;
        }
        .log-info { background: #f0f9ff; color: #0369a1; }
        .log-trade { background: #f0fdf4; color: #15803d; }
        .log-warning { background: #fef9c3; color: #ca8a04; }
        .tab-btn {
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
        }
        .tab-btn:hover {
            color: #2563eb;
        }
        .tab-btn.active {
            color: #2563eb;
            border-bottom-color: #2563eb;
        }
        .tab-content {
            display: none;
        }
        .tab-content:not(.hidden) {
            display: block;
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- ä¸»å†…å®¹åŒº -->
    <div class="main-content">
        <div class="px-6 pb-6">
            <!-- é¡¶éƒ¨æ ‡é¢˜æ  -->
            <div class="bg-blue-600 text-white rounded-lg p-4 mb-4 flex justify-between items-center">
                <h1 class="text-2xl font-bold">ğŸ† AIé‡åŒ–ç«æŠ€åœº</h1>
                <div class="flex items-center gap-8">
                    <div id="startDate" class="text-lg">å¼€å§‹æ—¥æœŸ: 2025-01-01</div>
                    <div id="initialCapital" class="text-lg">åˆå§‹èµ„é‡‘: Â¥10,000.00</div>
                </div>
            </div>
            
            <!-- è¿›åº¦æ¡ï¼ˆå·²éšè—ï¼‰ -->
            <div class="card" style="display: none;">
                <div class="flex justify-between mb-2">
                    <span id="progressText" class="text-gray-700">ç­‰å¾…å¼€å§‹...</span>
                    <span id="progressPercent" class="text-gray-700">0%</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>
            
            <!-- èµ„äº§å¡ç‰‡ -->
            <div id="assetCards" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3 mb-3">
                <!-- åŠ¨æ€ç”Ÿæˆ -->
            </div>
            
            <!-- èµ„é‡‘æ›²çº¿å›¾ -->
            <div class="card">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold">ğŸ“ˆ èµ„é‡‘æ›²çº¿</h2>
                    <button id="replayBtn" onclick="toggleReplay()" 
                            class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors text-sm font-medium">
                        â¯ï¸ å›æ”¾
                    </button>
                </div>
                <div id="chart" style="width: 100%; height: 500px;"></div>
            </div>
            
        </div>
    </div>
    
    <!-- å³ä¾§é¢æ¿ï¼šæ’å + Tabå†…å®¹ -->
    <div class="right-panel">
        <!-- æ’åæ¦œå·²åˆå¹¶åˆ°å·¦ä¾§æ¨¡å‹å¡ç‰‡ -->
        
        <!-- Tabæ ‡ç­¾é¡µ -->
        <div class="flex flex-col" style="flex: 1; overflow: hidden;">
            <!-- Tabå¯¼èˆª -->
            <div class="flex border-b border-gray-200 px-6 pt-6">
                <button class="tab-btn active px-4 py-2 font-bold" onclick="switchTab('ai')">ğŸ’­ AIæ€è€ƒ</button>
                <button class="tab-btn px-4 py-2 font-bold" onclick="switchTab('trades')">ğŸ“‹ äº¤æ˜“è®°å½•</button>
                <button class="tab-btn px-4 py-2 font-bold" onclick="switchTab('holdings')">ğŸ’¼ æŒä»“</button>
            </div>
            
            <!-- Tabå†…å®¹ï¼ˆè‡ªåŠ¨å¡«å……é«˜åº¦ï¼‰ -->
            <div id="tab-ai" class="tab-content px-6 pb-6" style="flex: 1; overflow-y: auto;">
                <div id="aiLogs">
                    <div class="text-center text-gray-400 py-8">ç­‰å¾…AIå¼€å§‹æ€è€ƒ...</div>
                </div>
            </div>
            
            <div id="tab-trades" class="tab-content px-6 pb-6" style="display: none; flex: 1; overflow-y: auto;">
                <div id="tradesTableRight">
                    <div class="text-center text-gray-400 text-xs py-4">æš‚æ— äº¤æ˜“è®°å½•</div>
                </div>
            </div>
            
            <div id="tab-holdings" class="tab-content px-6 pb-6" style="display: none; flex: 1; overflow-y: auto;">
                <div id="holdingsTableRight">
                    <div class="text-center text-gray-400 text-xs py-4">æš‚æ— æŒä»“</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // APIåŸºç¡€URL
        const API_BASE = window.API_BASE || `${window.location.protocol}//${window.location.hostname}:8000`;
        
        // EChartså®ä¾‹
        let chart = null;
        let config = null;
        let lastLogCount = 0;  // ç”¨äºå¢é‡æ›´æ–°æ—¥å¿—ï¼ˆå·²åºŸå¼ƒï¼‰
        let lastLogsHash = '';  // ç”¨äºåˆ¤æ–­æ—¥å¿—å†…å®¹æ˜¯å¦å˜åŒ–
        
        // è­¦å‘Šå»é‡ï¼šè®°å½•å·²ç»è­¦å‘Šè¿‡çš„æ¨¡å‹ï¼Œé¿å…é‡å¤è­¦å‘Š
        const warnedModels = new Set();
        
        // å›æ”¾ç›¸å…³å˜é‡
        let replayState = {
            isPlaying: false,
            currentIndex: 0,
            fullData: null,  // å®Œæ•´å†å²æ•°æ®
            allDates: [],    // æ‰€æœ‰æ—¥æœŸ
            fixedAxisConfig: null,  // å›æ”¾æ—¶ä½¿ç”¨çš„åæ ‡è½´é…ç½®
            savedAxisConfig: null,  // ä¿å­˜çš„å½“å‰è§†å›¾åæ ‡è½´é…ç½®
            intervalId: null,
            normalUpdateIntervalId: null,  // ä¿å­˜æ­£å¸¸æ›´æ–°çš„intervalId
            totalDuration: 15000,  // å›ºå®šæ€»æ—¶é•¿15ç§’
            interpolationSteps: 10,  // æ¯ä¸¤å¤©ä¹‹é—´æ’å€¼10å¸§ï¼ˆæµç•…åº¦ï¼‰
            speed: 100,  // åŠ¨æ€è®¡ç®—ï¼šæ€»æ—¶é•¿ / (æ€»å¤©æ•° * æ’å€¼æ­¥æ•°)
            currentSubStep: 0,  // å½“å‰å­æ­¥éª¤
            isReplayMode: false,  // æ˜¯å¦å¤„äºå›æ”¾æ¨¡å¼ï¼ˆç”¨äºéšè—æ³¢çº¹ï¼‰
            needCatchUpAnimation: false,  // å›æ”¾ç»“æŸåæ˜¯å¦éœ€è¦è¿½èµ¶åŠ¨ç”»
            justFinishedReplay: false  // åˆšç»“æŸå›æ”¾ï¼ˆç”¨äºåªæ·»åŠ æ³¢çº¹ï¼Œä¸é‡å»ºæ›²çº¿ï¼‰
        };
        
        // åˆå§‹åŒ–
        async function init() {
            // åŠ è½½é…ç½®
            const configRes = await fetch(`${API_BASE}/api/arena/config`);
            config = await configRes.json();

            if (!config || typeof config !== 'object') {
                config = {};
            }

            // âœ… é˜²å¾¡ï¼šå³ä½¿åç«¯ç¼ºå­—æ®µä¹Ÿæä¾›é»˜è®¤å€¼
            if (config.initial_capital === undefined || config.initial_capital === null) {
                config.initial_capital = 10000;
            }
            if (!config.start_date) {
                config.start_date = '20250101';
            }
            if (!Array.isArray(config.models)) {
                config.models = [];
            }

            // æ›´æ–°åˆå§‹èµ„é‡‘å’Œå¼€å§‹æ—¥æœŸ
            const capitalValue = Number(config.initial_capital) || 10000;
            document.getElementById('initialCapital').textContent = 
                `åˆå§‹èµ„é‡‘: Â¥${capitalValue.toLocaleString()}.00`;

            // æ ¼å¼åŒ–å¹¶æ˜¾ç¤ºå¼€å§‹æ—¥æœŸï¼ˆä» config.json è¯»å–ï¼‰
            const startDate = config.start_date || '20250101';
            const formattedStartDate = `${startDate.substr(0,4)}-${startDate.substr(4,2)}-${startDate.substr(6,2)}`;
            document.getElementById('startDate').textContent = `å¼€å§‹æ—¥æœŸ: ${formattedStartDate}`;
            
            // åˆå§‹åŒ–å›¾è¡¨
            chart = echarts.init(document.getElementById('chart'));
            
            // ç”Ÿæˆèµ„äº§å¡ç‰‡
            generateAssetCards();
            
            // å¼€å§‹å®šæ—¶åˆ·æ–°
            startPolling();
        }
        
        // ç”Ÿæˆèµ„äº§å¡ç‰‡
        // å½“å‰é«˜äº®çš„æ¨¡å‹
        let highlightedModel = null;
        
        function generateAssetCards() {
            // âœ… åˆå§‹å ä½å¡ç‰‡ï¼ˆæ•°æ®åŠ è½½åä¼šç”±updateAssetCardsé‡æ–°ç”Ÿæˆå¹¶æ’åºï¼‰
            const container = document.getElementById('assetCards');
            container.innerHTML = config.models.map((model) => `
                <div class="card model-card" 
                     style="border-left-color: ${model.color}"
                     data-model-name="${model.name}"
                     data-series-index="${model.index}"
                     onclick="toggleModelHighlight('${model.name}', ${model.index})">
                    <div class="flex items-center justify-between mb-2">
                        <div class="flex items-center">
                            ${model.logo ? `<img src="${model.logo}" class="w-7 h-7 mr-1.5" />` : ''}
                            <h3 class="text-base font-bold truncate">${model.name}</h3>
                        </div>
                        <span class="text-lg font-bold text-gray-400">-</span>
                    </div>
                    <div class="text-xl font-bold text-gray-800 mb-1">
                        Â¥10,000.00
                    </div>
                    <div class="text-sm font-medium text-gray-600 mb-1">
                        0.00%
                    </div>
                    <div class="text-sm font-medium text-gray-600">
                        ğŸ’° å¯ç”¨: Â¥10,000.00
                    </div>
                </div>
            `).join('');
        }
        
        // åˆ‡æ¢æ¨¡å‹é«˜äº®
        function toggleModelHighlight(modelName, cardIndex) {
            const option = chart.getOption();
            
            // é€šè¿‡nameæŸ¥æ‰¾å®é™…çš„seriesIndexï¼ˆå› ä¸ºæœ‰filteræ“ä½œï¼ŒcardIndexå¯èƒ½ä¸å‡†ç¡®ï¼‰
            const seriesIndex = option.series.findIndex(s => s.name === modelName);
            if (seriesIndex === -1) return;  // æœªæ‰¾åˆ°å¯¹åº”series
            
            if (highlightedModel === modelName) {
                // å–æ¶ˆé«˜äº® - æ¢å¤æ‰€æœ‰æ›²çº¿å’Œå›¾æ ‡
                option.series.forEach((s, idx) => {
                    if (s.name !== 'åˆå§‹èµ„é‡‘' && !s.name.includes('_ripple')) {
                        s.lineStyle = {
                            ...s.lineStyle,
                            width: 2,
                            opacity: 1
                        };
                        // æ¢å¤markPointå›¾æ ‡é€æ˜åº¦
                        if (s.markPoint && s.markPoint.data) {
                            s.markPoint.data.forEach(point => {
                                if (point.itemStyle) {
                                    point.itemStyle.opacity = 1;
                                }
                            });
                        }
                    }
                });
                chart.setOption(option, { notMerge: false, lazyUpdate: true, silent: true });
                highlightedModel = null;
                
                // ç§»é™¤å¡ç‰‡é«˜äº®æ ·å¼
                document.querySelectorAll('.model-card').forEach(card => {
                    card.style.opacity = '1';
                    card.style.transform = 'scale(1)';
                });
            } else {
                // é«˜äº®é€‰ä¸­çš„æ›²çº¿å’Œå›¾æ ‡ï¼Œå…¶ä»–å˜æ·¡
                option.series.forEach((s, idx) => {
                    if (s.name !== 'åˆå§‹èµ„é‡‘' && !s.name.includes('_ripple')) {
                        if (idx === seriesIndex) {
                            // ç‚¹å‡»çš„æ›²çº¿ï¼šåŠ ç²—ï¼Œä¸é€æ˜
                            s.lineStyle = {
                                ...s.lineStyle,
                                width: 4,
                                opacity: 1
                            };
                            // markPointå›¾æ ‡ä¿æŒä¸é€æ˜
                            if (s.markPoint && s.markPoint.data) {
                                s.markPoint.data.forEach(point => {
                                    if (point.itemStyle) {
                                        point.itemStyle.opacity = 1;
                                    }
                                });
                            }
                        } else {
                            // å…¶ä»–æ›²çº¿ï¼šæ­£å¸¸ç²—ç»†ï¼Œå˜é€æ˜
                            s.lineStyle = {
                                ...s.lineStyle,
                                width: 2,
                                opacity: 0.3
                            };
                            // markPointå›¾æ ‡ä¹Ÿå˜æ·¡
                            if (s.markPoint && s.markPoint.data) {
                                s.markPoint.data.forEach(point => {
                                    if (point.itemStyle) {
                                        point.itemStyle.opacity = 0.3;
                                    }
                                });
                            }
                        }
                    }
                });
                chart.setOption(option, { notMerge: false, lazyUpdate: true, silent: true });
                highlightedModel = modelName;
                
                // æ›´æ–°å¡ç‰‡è§†è§‰æ•ˆæœ
                document.querySelectorAll('.model-card').forEach(card => {
                    if (card.dataset.modelName === modelName) {
                        card.style.opacity = '1';
                        card.style.transform = 'scale(1.05)';
                    } else {
                        card.style.opacity = '0.5';
                        card.style.transform = 'scale(1)';
                    }
                });
            }
        }
        
        // æ›´æ–°UI
        async function updateUI() {
            try {
                // è·å–æ•°æ®
                const [dataRes, progressRes, rankingsRes] = await Promise.all([
                    fetch(`${API_BASE}/api/arena/data`),
                    fetch(`${API_BASE}/api/arena/progress`),
                    fetch(`${API_BASE}/api/arena/rankings`)
                ]);
                
                const data = await dataRes.json();
                const progress = await progressRes.json();
                const rankings = await rankingsRes.json();
                
                // ğŸ” è°ƒè¯•ï¼šæ‰“å°æ•°æ®
                console.log('ğŸ“Š updateUI è·å–åˆ°æ•°æ®:', {
                    models: Object.keys(data),
                    modelCount: Object.keys(data).length,
                    progress: progress.percent + '%',
                    timestamp: new Date().toLocaleTimeString()
                });
                
                // æ›´æ–°è¿›åº¦
                updateProgress(progress);
                updateAssetCards(data);
                updateChart(data);
                // updateRankings(rankings.rankings);  // å·²åˆå¹¶åˆ°å¡ç‰‡
                updateTradesTable(data);
                updateHoldingsTable(data);
                
                // æ›´æ–°AIæ—¥å¿—ï¼ˆå¢é‡ï¼‰
                await updateAILogs();
                
            } catch (error) {
                console.error('æ›´æ–°UIå¤±è´¥:', error);
            }
        }
        
        // æ›´æ–°è¿›åº¦
        function updateProgress(progress) {
            // âœ… åªåœ¨å›æ”¾æ¨¡å¼ä¸‹æ˜¾ç¤ºè¿›åº¦æ¡ï¼ˆæ­£å¸¸æ¨¡å¼ä¸éœ€è¦è¿›åº¦æ¡ï¼‰
            if (!replayState.isPlaying) {
                return;  // æ­£å¸¸æ¨¡å¼ä¸æ›´æ–°è¿›åº¦æ¡
            }
            
            document.getElementById('progressText').textContent = progress.message || 'ç­‰å¾…å¼€å§‹...';
            document.getElementById('progressPercent').textContent = `${progress.percent}%`;
            document.getElementById('progressBar').style.width = `${progress.percent}%`;
        }
        
        // æ›´æ–°èµ„äº§å¡ç‰‡ï¼ˆæŒ‰æ’åæ’åºï¼‰
        function updateAssetCards(data) {
            // âœ… åˆ¤æ–­æ˜¯å¦å·²ç»å¼€å§‹ï¼šæ£€æŸ¥æ˜¯å¦æœ‰äº¤æ˜“è®°å½•æˆ–èµ„äº§å˜åŒ–
            let hasStarted = false;
            const initialCapital = config.initial_capital || 10000; // ä»é…ç½®è·å–
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•æ¨¡å‹çš„äº¤æ˜“è®°å½•æˆ–èµ„äº§å˜åŒ–
            for (const model of config.models) {
                const modelData = data[model.id];
                if (!modelData) continue;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰äº¤æ˜“è®°å½•
                const trades = modelData.trades || [];
                if (trades.length > 0) {
                    hasStarted = true;
                    break;
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰daily_assetsæ•°æ®ä¸”ä¸æ˜¯åˆå§‹å€¼ï¼ˆæœ‰å¤šä¸ªæ•°æ®ç‚¹æˆ–èµ„äº§æœ‰å˜åŒ–ï¼‰
                const dailyAssets = modelData.daily_assets || [];
                if (dailyAssets.length > 1) {
                    hasStarted = true;
                    break;
                }
                if (dailyAssets.length === 1) {
                    const assets = dailyAssets[0].total_assets;
                    if (assets !== initialCapital) {
                        hasStarted = true;
                        break;
                    }
                }
            }
            
            // âœ… åˆ›å»ºæ¨¡å‹æ•°æ®æ•°ç»„ï¼Œä½¿ç”¨daily_assetsçš„æœ€æ–°å€¼
            const modelDataArray = config.models.map(model => {
                const modelData = data[model.id];  // âœ… ä½¿ç”¨idè€Œä¸æ˜¯name
                if (!modelData) return null;
                
                // âœ… ä½¿ç”¨daily_assetsçš„æœ€æ–°å€¼ä½œä¸ºtotal_assetsï¼ˆä¸å›¾è¡¨ä¿æŒä¸€è‡´ï¼‰
                const dailyAssets = modelData.daily_assets || [];
                if (dailyAssets.length > 0) {
                    const latestAssets = dailyAssets[dailyAssets.length - 1].total_assets;
                    return {
                        ...model,
                        data: {
                            ...modelData,
                            total_assets: latestAssets,  // ä½¿ç”¨æœ€æ–°å€¼
                            profit_pct: ((latestAssets - initialCapital) / initialCapital) * 100
                        }
                    };
                }
                return { ...model, data: modelData };
            }).filter(m => m && m.data)  // è¿‡æ»¤æ‰æ²¡æœ‰æ•°æ®çš„æ¨¡å‹
              .sort((a, b) => (b.data.profit_pct || 0) - (a.data.profit_pct || 0));  // æŒ‰æ”¶ç›Šç‡é™åº
            
            // âœ… é‡æ–°ç”Ÿæˆå¡ç‰‡HTMLï¼ˆæŒ‰æ’åé¡ºåºï¼Œä½†æœªå¼€å§‹æ—¶ä¸æ˜¾ç¤ºæ’åï¼‰
            const container = document.getElementById('assetCards');
            container.innerHTML = modelDataArray.map((model, idx) => {
                const modelData = model.data;
                const profitPct = modelData.profit_pct;
                const rank = idx + 1;
                const medal = rank === 1 ? 'ğŸ¥‡' : rank === 2 ? 'ğŸ¥ˆ' : rank === 3 ? 'ğŸ¥‰' : `${rank}`;
                
                return `
                    <div class="card model-card" 
                         style="border-left-color: ${model.color}"
                         data-model-name="${model.name}"
                         data-series-index="${model.index}"
                         onclick="toggleModelHighlight('${model.name}', ${model.index})">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center">
                                ${model.logo ? `<img src="${model.logo}" class="w-7 h-7 mr-1.5" />` : ''}
                                <h3 class="text-base font-bold truncate">${model.name}</h3>
                            </div>
                            ${hasStarted ? `<span class="text-lg font-bold">${medal}</span>` : ''}
                        </div>
                        <div class="text-xl font-bold text-gray-800 mb-1">
                            Â¥${modelData.total_assets.toLocaleString()}
                        </div>
                        <div class="text-sm font-medium ${profitPct >= 0 ? 'text-red-600' : 'text-green-600'} mb-1">
                            ${profitPct >= 0 ? '+' : ''}${profitPct.toFixed(2)}%
                        </div>
                        <div class="text-sm font-medium text-gray-600">
                            ğŸ’° å¯ç”¨: Â¥${(modelData.cash || 0).toLocaleString()}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // æ›´æ–°å›¾è¡¨ï¼ˆä½¿ç”¨åæ ‡å¯¹ï¼Œé¿å…æ•°æ®é”™ä½ï¼‰
        function updateChart(data) {
            // âœ… å›æ”¾æ—¶ä½¿ç”¨å›ºå®šçš„å®Œæ•´æ—¥æœŸåˆ—è¡¨ï¼Œæ­£å¸¸æ¨¡å¼åŠ¨æ€è®¡ç®—
            let allDates;
            if (replayState.isPlaying && replayState.allDates && replayState.allDates.length > 0) {
                // å›æ”¾æ¨¡å¼ï¼šä½¿ç”¨å›ºå®šçš„å®Œæ•´æ—¥æœŸåˆ—è¡¨ï¼ˆæ¨ªè½´ä¸å˜ï¼‰
                allDates = replayState.allDates;
            } else {
                // âœ… æ­£å¸¸æ¨¡å¼ï¼šåŒæ­¥æ˜¾ç¤ºé€»è¾‘ - åªæ˜¾ç¤ºåˆ°æ‰€æœ‰æ¨¡å‹éƒ½æœ‰çš„æœ€æ–°æ—¥æœŸ
                // å‰ç«¯å¯ä»¥ä»åç«¯è·å–æ‰€æœ‰æ•°æ®ï¼ˆåŒ…æ‹¬æœªæ¥çš„ï¼‰ï¼Œä½†æ˜¾ç¤ºæ—¶åªæ˜¾ç¤ºåˆ°åŒæ­¥æ—¥æœŸ
                // è¿™æ ·è½åçš„æ¨¡å‹å¯ä»¥ç­‰å¾…ï¼Œç¡®ä¿æ‰€æœ‰æ¨¡å‹é½å¤´å¹¶è¿›
                // 1. å…ˆæ‰¾å‡ºæ¯ä¸ªæ¨¡å‹æœ€æ–°æ—¥æœŸçš„é›†åˆ
                const modelLatestDates = [];
                const modelDateMap = {}; // {modelId: latestDate}
                config.models.forEach(model => {
                    const modelData = data[model.id];
                    if (modelData && modelData.daily_assets && modelData.daily_assets.length > 0) {
                        // è·å–è¯¥æ¨¡å‹æœ€æ–°çš„æ—¥æœŸ
                        const latestDate = modelData.daily_assets[modelData.daily_assets.length - 1].date;
                        modelLatestDates.push(latestDate);
                        modelDateMap[model.id] = latestDate;
                    }
                });
                
                // 2. âœ… æ–°é€»è¾‘ï¼šå…è®¸Agentæœ€å¤šé¢†å…ˆ2å¤©ï¼Œä½†åªè¦æœ‰å½“å¤©çš„ç»“æœå°±æ˜¾ç¤º
                // è®¡ç®—åŒæ­¥æ—¥æœŸ = min(æœ€æ…¢æ—¥æœŸ + 2å¤©, æœ€å¿«æ—¥æœŸ)
                let syncDate = null;
                if (modelLatestDates.length === config.models.length) {
                    // æ‰€æœ‰æ¨¡å‹éƒ½æœ‰æ•°æ®
                    const sortedDates = modelLatestDates.sort((a, b) => {
                        const dateA = new Date(a.substr(0,4), a.substr(4,2)-1, a.substr(6,2));
                        const dateB = new Date(b.substr(0,4), b.substr(4,2)-1, b.substr(6,2));
                        return dateA - dateB;
                    });
                    
                    const minDate = sortedDates[0];  // æœ€æ…¢çš„æ¨¡å‹
                    const maxDate = sortedDates[sortedDates.length - 1];  // æœ€å¿«çš„æ¨¡å‹
                    
                    // è¾…åŠ©å‡½æ•°ï¼šæ—¥æœŸå­—ç¬¦ä¸²åŠ Nå¤©
                    function addDays(dateStr, days) {
                        const year = parseInt(dateStr.substr(0, 4));
                        const month = parseInt(dateStr.substr(4, 2)) - 1;
                        const day = parseInt(dateStr.substr(6, 2));
                        const date = new Date(year, month, day);
                        date.setDate(date.getDate() + days);
                        const y = date.getFullYear();
                        const m = String(date.getMonth() + 1).padStart(2, '0');
                        const d = String(date.getDate()).padStart(2, '0');
                        return y + m + d;
                    }
                    
                    // è®¡ç®—æ—¥æœŸå·®ï¼ˆå¤©æ•°ï¼‰
                    function daysBetween(dateStr1, dateStr2) {
                        const d1 = new Date(parseInt(dateStr1.substr(0,4)), parseInt(dateStr1.substr(4,2))-1, parseInt(dateStr1.substr(6,2)));
                        const d2 = new Date(parseInt(dateStr2.substr(0,4)), parseInt(dateStr2.substr(4,2))-1, parseInt(dateStr2.substr(6,2)));
                        const diffTime = Math.abs(d2 - d1);
                        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                        return diffDays;
                    }
                    
                    const daysDiff = daysBetween(minDate, maxDate);
                    
                    if (daysDiff <= 2) {
                        // å¦‚æœå·®è·<=2å¤©ï¼Œå…è®¸æ˜¾ç¤ºæ‰€æœ‰å½“å¤©çš„ç»“æœï¼ˆæ˜¾ç¤ºåˆ°æœ€å¿«æ—¥æœŸï¼‰
                        syncDate = maxDate;
                    } else {
                        // å¦‚æœå·®è·>2å¤©ï¼Œé™åˆ¶åªæ˜¾ç¤ºåˆ°æœ€æ…¢+2å¤©ï¼ˆä¸å…è®¸è¶…è¿‡2å¤©ï¼‰
                        syncDate = addDays(minDate, 2);
                    }
                    
                    // ğŸ” è°ƒè¯•ä¿¡æ¯
                    if (daysDiff > 0) {
                        console.log(`âœ… åŒæ­¥æ˜¾ç¤º: æ—¥æœŸå·®è·${daysDiff}å¤©ï¼ˆæœ€æ…¢: ${minDate}, æœ€å¿«: ${maxDate}, æ˜¾ç¤ºåˆ°: ${syncDate}ï¼‰`);
                    }
                } else {
                    // æœ‰äº›æ¨¡å‹è¿˜æ²¡æœ‰æ•°æ®ï¼Œç­‰å¾…æ‰€æœ‰æ¨¡å‹éƒ½æœ‰æ•°æ®
                    syncDate = null;
                }
                
                // 3. æ”¶é›†æ—¥æœŸï¼šåªæ”¶é›†åˆ°åŒæ­¥æ—¥æœŸä¸ºæ­¢çš„æ—¥æœŸ
                const allDatesSet = new Set();
                if (syncDate) {
                    // æ”¶é›†æ‰€æœ‰æ¨¡å‹åœ¨åŒæ­¥æ—¥æœŸä¹‹å‰ï¼ˆå«ï¼‰çš„æ‰€æœ‰æ—¥æœŸ
                Object.values(data).forEach(modelData => {
                    if (modelData.daily_assets) {
                        modelData.daily_assets.forEach(d => {
                                const dateNum = parseInt(d.date);
                                const syncDateNum = parseInt(syncDate);
                                if (dateNum <= syncDateNum) {
                            allDatesSet.add(d.date);
                                }
                        });
                    }
                });
                } else if (modelLatestDates.length > 0) {
                    // éƒ¨åˆ†æ¨¡å‹æœ‰æ•°æ®ä½†æœªå…¨éƒ¨åŒæ­¥ï¼šæ˜¾ç¤ºå·²æœ‰æ•°æ®ï¼ˆå‘åå…¼å®¹ï¼‰
                    Object.values(data).forEach(modelData => {
                        if (modelData.daily_assets) {
                            modelData.daily_assets.forEach(d => {
                                allDatesSet.add(d.date);
                            });
                        }
                    });
                }
                
                allDates = Array.from(allDatesSet).sort((a, b) => {
                    // æŒ‰æ—¥æœŸå€¼æ’åºï¼Œè€Œä¸æ˜¯å­—ç¬¦ä¸²å­—å…¸åº
                    const dateA = new Date(a.substr(0,4), a.substr(4,2)-1, a.substr(6,2));
                    const dateB = new Date(b.substr(0,4), b.substr(4,2)-1, b.substr(6,2));
                    return dateA - dateB;
                });
            }
            
            // âœ… åœ¨æœ«å°¾æ·»åŠ 3ä¸ªç©ºç™½æ—¥æœŸï¼ˆç”¨äºå³ä¾§ç•™ç™½ï¼‰- ä»…æ­£å¸¸æ¨¡å¼éœ€è¦
            if (!replayState.isPlaying && allDates.length > 0) {
                const lastDate = allDates[allDates.length - 1];
                const year = parseInt(lastDate.substr(0, 4));
                const month = parseInt(lastDate.substr(4, 2));
                const day = parseInt(lastDate.substr(6, 2));
                
                for (let i = 1; i <= 3; i++) {
                    const nextDate = new Date(year, month - 1, day + i);
                    const nextDateStr = `${nextDate.getFullYear()}${String(nextDate.getMonth() + 1).padStart(2, '0')}${String(nextDate.getDate()).padStart(2, '0')}`;
                    allDates.push(nextDateStr);
                }
            }
            
            const series = config.models.map(model => {
                const modelData = data[model.id];  // âœ… ä½¿ç”¨idè€Œä¸æ˜¯name
                if (!modelData || !modelData.daily_assets) {
                    // ä½¿ç”¨ debug çº§åˆ«ï¼Œä¸ä¼šåœ¨æ§åˆ¶å°é»˜è®¤æ˜¾ç¤ºï¼ˆéœ€è¦å¼€å¯è¯¦ç»†æ—¥å¿—ï¼‰
                    if (!warnedModels.has(model.id + '_empty')) {
                        console.debug(`[DEBUG] updateChart: æ¨¡å‹ ${model.name} çš„æ•°æ®ä¸ºç©º`, modelData);
                        warnedModels.add(model.id + '_empty');
                    }
                    return null;
                }
                if (modelData.daily_assets.length === 0) {
                    // ä½¿ç”¨ debug çº§åˆ«ï¼Œä¸ä¼šåœ¨æ§åˆ¶å°é»˜è®¤æ˜¾ç¤ºï¼ˆéœ€è¦å¼€å¯è¯¦ç»†æ—¥å¿—ï¼‰
                    if (!warnedModels.has(model.id + '_empty_array')) {
                        console.debug(`[DEBUG] updateChart: æ¨¡å‹ ${model.name} çš„ daily_assets ä¸ºç©ºæ•°ç»„`);
                        warnedModels.add(model.id + '_empty_array');
                    }
                    return null;
                }
                
                // âœ… å¦‚æœæ¨¡å‹æœ‰æ•°æ®äº†ï¼Œæ¸…é™¤ä¹‹å‰çš„è­¦å‘Šè®°å½•ï¼ˆå…è®¸é‡æ–°è­¦å‘Šå¦‚æœæ•°æ®å†æ¬¡å˜ç©ºï¼‰
                if (modelData.daily_assets.length > 0) {
                    warnedModels.delete(model.id + '_empty');
                    warnedModels.delete(model.id + '_empty_array');
                }
                
                // åˆ›å»ºæ—¥æœŸåˆ°èµ„äº§çš„æ˜ å°„
                const dateMap = {};
                modelData.daily_assets.forEach(d => {
                    if (d && d.date) {  // ç¡®ä¿dä¸æ˜¯nullä¸”æœ‰dateå­—æ®µ
                        dateMap[d.date] = d.total_assets;
                    }
                });
                
                // æŒ‰æ‰€æœ‰æ—¥æœŸæ„å»ºæ•°æ®ï¼ˆæ²¡æœ‰æ•°æ®çš„æ—¥æœŸç”¨nullï¼‰
                const dataPoints = allDates.map(date => dateMap[date] !== undefined ? dateMap[date] : null);

                // æ‰¾åˆ°è¯¥æ¨¡å‹æœ€åä¸€æ¡æœ‰æ•ˆæ•°æ®çš„ç´¢å¼•
                const lastDataDate = modelData.daily_assets.length > 0
                    ? modelData.daily_assets[modelData.daily_assets.length - 1].date
                    : null;
                const lastDataIndex = lastDataDate ? allDates.indexOf(lastDataDate) : -1;

                if (lastDataIndex >= 0) {
                    // âœ… ä»…åœ¨æœ‰æ•ˆæ•°æ®èŒƒå›´å†…å¡«å……nullï¼Œé¿å…åœ¨å³ä¾§ç•™ç™½åŒºåŸŸç”»çº¿
                    let hasStarted = false; // æ˜¯å¦å·²ç»æœ‰è¿‡æ•°æ®
                    let lastValidValue = null;

                    for (let i = 0; i <= lastDataIndex; i++) {
                        if (dataPoints[i] !== null) {
                            hasStarted = true;
                            lastValidValue = dataPoints[i];
                        } else if (hasStarted && lastValidValue !== null) {
                            // åªåœ¨"å·²ç»æœ‰è¿‡æ•°æ®"åæ‰å¡«å……nullï¼ˆä¿æŒæ°´å¹³çº¿ï¼‰
                            dataPoints[i] = lastValidValue;
                        }
                        // else: å¼€å¤´çš„nullä¿æŒnullï¼ˆä¸ç”»çº¿ï¼‰
                    }

                    // âœ… åŠ¨æ€å¡«å……nullå€¼ï¼ˆçº¿æ€§æ’å€¼ï¼‰ï¼Œä»…å¤„ç†æœ‰æ•ˆæ•°æ®èŒƒå›´
                    for (let i = 0; i <= lastDataIndex; i++) {
                        if (dataPoints[i] === null) {
                            // æ‰¾åˆ°å‰ä¸€ä¸ªénullå€¼
                            let prevValue = null;
                            let prevIndex = -1;
                            for (let j = i - 1; j >= 0; j--) {
                                if (dataPoints[j] !== null) {
                                    prevValue = dataPoints[j];
                                    prevIndex = j;
                                    break;
                                }
                            }

                            // æ‰¾åˆ°åä¸€ä¸ªénullå€¼ï¼ˆé™åˆ¶åœ¨æœ‰æ•ˆèŒƒå›´å†…ï¼‰
                            let nextValue = null;
                            let nextIndex = -1;
                            for (let j = i + 1; j <= lastDataIndex; j++) {
                                if (dataPoints[j] !== null) {
                                    nextValue = dataPoints[j];
                                    nextIndex = j;
                                    break;
                                }
                            }

                            // çº¿æ€§æ’å€¼å¡«å……
                            if (prevValue !== null && nextValue !== null && nextIndex > prevIndex) {
                                const ratio = (i - prevIndex) / (nextIndex - prevIndex);
                                dataPoints[i] = prevValue + (nextValue - prevValue) * ratio;
                            } else if (prevValue !== null) {
                                // åªæœ‰å‰å€¼ï¼Œä¿æŒä¸å˜
                                dataPoints[i] = prevValue;
                            } else if (nextValue !== null) {
                                // åªæœ‰åå€¼ï¼Œä½¿ç”¨åå€¼
                                dataPoints[i] = nextValue;
                            }
                        }
                    }
                }
                
                // âœ… æˆªæ–­æ•°æ®åˆ°æœ€åä¸€ä¸ªæœ‰æ•ˆæ•°æ®ç‚¹ï¼Œé¿å…å›é€€åçº¿å»¶ä¼¸åˆ°æœªæ¥
                if (lastDataIndex >= 0 && lastDataIndex < dataPoints.length - 1) {
                    dataPoints.splice(lastDataIndex + 1);
                }
                
                // è·å–æœ€æ–°èµ„äº§å’Œæ—¥æœŸç´¢å¼•
                const latestAssets = modelData.daily_assets.length > 0 ? 
                    modelData.daily_assets[modelData.daily_assets.length - 1].total_assets : 0;
                
                // âœ… æˆªæ–­åï¼ŒlatestDateIndex å°±æ˜¯ dataPoints çš„æœ€åä¸€ä¸ªç´¢å¼•
                let latestDateIndex = lastDataIndex >= 0 ? lastDataIndex : -1;
                
                // å®¹é”™ï¼šå¦‚æœ lastDataIndex æ— æ•ˆï¼Œfallback åˆ°æœ€åä¸€ä¸ªæœ‰æ•°æ®çš„ç´¢å¼•
                if (latestDateIndex === -1 && dataPoints.length > 0) {
                    // æ‰¾åˆ°æœ€åä¸€ä¸ªæœ‰æ•°æ®çš„æ—¥æœŸç´¢å¼•
                    for (let i = dataPoints.length - 1; i >= 0; i--) {
                        if (dataPoints[i] !== null) {
                            latestDateIndex = i;
                            console.log(`âœ… ${model.name}: fallbackåˆ°ç´¢å¼• ${i}`);
                            break;
                        }
                    }
                }
                
                // æœ€ç»ˆfallbackï¼šå¦‚æœè¿˜æ˜¯-1ï¼Œä½¿ç”¨æœ€åä¸€ä¸ªç´¢å¼•
                if (latestDateIndex === -1 && dataPoints.length > 0) {
                    latestDateIndex = dataPoints.length - 1;
                    console.warn(`âš ï¸ ${model.name}: å¼ºåˆ¶fallbackåˆ°ç´¢å¼• ${latestDateIndex}`);
                }
                
                // éªŒè¯ç´¢å¼•æœ‰æ•ˆæ€§ï¼ˆé˜²æ­¢è¶…å‡ºæ¨ªè½´èŒƒå›´ï¼‰
                const maxValidIndex = allDates.length - 1;
                if (latestDateIndex > maxValidIndex) {
                    console.error(`âŒ ${model.name}: latestDateIndex(${latestDateIndex})è¶…å‡ºèŒƒå›´(${maxValidIndex})ï¼Œä¿®æ­£ä¸º${maxValidIndex}`);
                    latestDateIndex = maxValidIndex;
                }
                
                // console.log(`ğŸ“Š ${model.name}: latestDateIndex=${latestDateIndex}, latestAssets=${latestAssets}`);
                
                return {
                    name: model.name,
                    type: 'line',
                    data: dataPoints,
                    itemStyle: { 
                        color: model.color,
                        opacity: 0,  // symbolé€æ˜ä¸å¯è§
                        borderWidth: 0
                    },
                    lineStyle: { 
                        width: 2, 
                        color: model.color,
                        cap: 'round',
                        join: 'round'
                    },
                    smooth: true,
                    animation: true,  // å§‹ç»ˆå¯ç”¨åŠ¨ç”»ï¼ˆç”±å…¨å±€optionæ§åˆ¶æ—¶é•¿ï¼‰
                    symbol: 'circle',
                    symbolSize: 32,  // å¤§å¹…å¢åŠ åˆ°32pxè®©æ•´æ¡çº¿éƒ½å¯ä»¥æ•è·
                    showSymbol: true,  // æ˜¾ç¤ºé€æ˜symbolå¢åŠ æ•è·é¢ç§¯
                    sampling: 'lttb',  // ä¼˜åŒ–é‡‡æ ·
                    zlevel: 0,
                    z: 1,
                    emphasis: {
                        disabled: true  // å®Œå…¨ç¦ç”¨è‡ªåŠ¨emphasis
                    },
                    // æ ‡è®°ç‚¹æ˜¾ç¤ºæœ«ç«¯å›¾æ ‡å’Œæ ‡ç­¾
                    markPoint: latestDateIndex >= 0 ? {
                        silent: false,  // å…è®¸æ¥æ”¶é¼ æ ‡äº‹ä»¶
                        animation: false,  // å®Œå…¨ç¦ç”¨åŠ¨ç”»ï¼Œé æ’å€¼æ§åˆ¶
                        animationDuration: 0,
                        animationDurationUpdate: 0,
                        emphasis: {
                            scale: 1.2  // æ‚¬åœæ—¶æ”¾å¤§
                        },
                        data: [
                            // å›¾æ ‡
                            {
                                xAxis: latestDateIndex,
                                yAxis: latestAssets,
                                symbol: model.logo ? `image://${model.logo}` : 'circle',
                                symbolSize: model.logo ? [32, 32] : 30,
                                symbolOffset: [0, 0],
                                z: 999,  // å•ç‹¬è®¾ç½®zå±‚çº§ï¼Œç¡®ä¿åœ¨æœ€ä¸Šå±‚
                                itemStyle: {
                                    color: model.logo ? 'transparent' : model.color,
                                    borderColor: model.color,
                                    borderWidth: 3
                                },
                                emphasis: {
                                    itemStyle: {
                                        borderWidth: 4,  // è¾¹æ¡†åŠ ç²—
                                        shadowBlur: 10,
                                        shadowColor: model.color
                                    }
                                },
                                label: {
                                    show: false
                                }
                            },
                            // é‡‘é¢æ ‡ç­¾ï¼ˆé•¿æ–¹å½¢ï¼‰
                            {
                                xAxis: latestDateIndex,
                                yAxis: latestAssets,
                                symbol: 'rect',
                                symbolSize: [110, 26],
                                symbolOffset: [75, 0],  // ä¸å›¾æ ‡ä¿æŒ10pxé—´è·
                                z: 999,  // å•ç‹¬è®¾ç½®zå±‚çº§
                                itemStyle: {
                                    color: model.color,
                                    borderWidth: 0,
                                    borderRadius: 0
                                },
                                emphasis: {
                                    itemStyle: {
                                        shadowBlur: 8,
                                        shadowColor: model.color
                                    },
                                    label: {
                                        fontSize: 13  // å­—ä½“ç¨å¾®å˜å¤§
                                    }
                                },
                                label: {
                                    show: true,
                                    formatter: `Â¥${latestAssets.toLocaleString()}`,
                                    color: '#fff',
                                    fontSize: 12,
                                    fontWeight: 'bold',
                                    padding: [2, 8]
                                }
                            }
                        ]
                    } : undefined
                };
            }).filter(s => s !== null);
            
            // è°ƒè¯•ï¼šæ£€æŸ¥seriesçš„markPointé…ç½®ï¼ˆå·²æ³¨é‡Šï¼Œç”Ÿäº§ç¯å¢ƒä¸éœ€è¦ï¼‰
            // console.log(`ğŸ” è¿‡æ»¤åçš„seriesæ•°é‡: ${series.length}`);
            // series.forEach((s, i) => {
            //     if (s.markPoint) {
            //         console.log(`  âœ… Series ${i} (${s.name}): æœ‰markPoint, æ•°æ®ç‚¹æ•°=${s.markPoint.data?.length || 0}`);
            //     } else {
            //         console.log(`  âŒ Series ${i} (${s.name}): æ²¡æœ‰markPoint`);
            //     }
            // });
            
            // âœ… å›æ”¾æ—¶ä½¿ç”¨å›ºå®šçš„Yè½´èŒƒå›´ï¼Œæ­£å¸¸æ¨¡å¼åŠ¨æ€è®¡ç®—
            let yMin, yMax;
            const initialCapital = config.initial_capital || 10000;
            
            if (replayState.isPlaying && replayState.savedAxisConfig) {
                // å›æ”¾æ¨¡å¼ï¼šä½¿ç”¨å›ºå®šçš„Yè½´èŒƒå›´ï¼ˆçºµè½´ä¸å˜ï¼‰
                yMin = replayState.savedAxisConfig.yMin;
                yMax = replayState.savedAxisConfig.yMax;
            } else {
                // æ­£å¸¸æ¨¡å¼ï¼šåŠ¨æ€è®¡ç®—Yè½´èŒƒå›´ï¼ˆçºµè½´éšæ•°æ®å˜åŒ–ï¼‰
                let allAssets = [];
                series.forEach(s => {
                    if (s && s.data) {
                        s.data.forEach(d => {
                            if (d !== null) allAssets.push(d);
                        });
                    }
                });
                
                const minAsset = allAssets.length > 0 ? Math.min(...allAssets) : 10000;
                const maxAsset = allAssets.length > 0 ? Math.max(...allAssets) : 10000;
                
                // è®¡ç®—èŒƒå›´ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„paddingç•™ç»™æ ‡ç­¾
                const dataRange = maxAsset - minAsset;
                const minRange = initialCapital * 0.04;  // æœ€å°æ˜¾ç¤ºèŒƒå›´ï¼š4%
                const actualRange = Math.max(dataRange, minRange);
                const padding = actualRange * 0.1;  // 10% paddingç•™ç»™æ ‡ç­¾
                
                // åŸºäºå®é™…æ•°æ®èŒƒå›´è®¡ç®—Yè½´
                yMin = Math.floor((minAsset - padding) / 100) * 100;
                yMax = Math.ceil((maxAsset + padding) / 100) * 100;
            }
            
            // âœ… å›ºå®šå›¾è¡¨é«˜åº¦ï¼Œé€šè¿‡Yè½´åˆ»åº¦è‡ªé€‚åº”æ˜¾ç¤ºæ‰€æœ‰æ•°æ®
            const chartHeight = 600;  // å›ºå®šé«˜åº¦600px
            document.getElementById('chart').style.height = `${chartHeight}px`;
            
            // æ ¼å¼åŒ–Xè½´æ—¥æœŸæ ‡ç­¾
            const xAxisLabels = allDates.map(date => {
                return `${date.substr(4,2)}-${date.substr(6,2)}`;
            });
            
            // console.log(`ğŸ” updateChart: xAxisLabels.length=${xAxisLabels.length}, allDates.length=${allDates.length}`);
            
            // åˆ›å»ºæ³¢çº¹æ•ˆæœç³»åˆ—ï¼ˆeffectScatterï¼‰- å›æ”¾æ—¶ä¸æ˜¾ç¤º
            const rippleEffects = replayState.isPlaying ? [] : config.models.map((model, idx) => {
                const modelData = data[model.id];  // âœ… ä½¿ç”¨idè€Œä¸æ˜¯name
                if (!modelData || !modelData.daily_assets || modelData.daily_assets.length === 0) return null;
                
                const latestAssets = modelData.daily_assets[modelData.daily_assets.length - 1].total_assets;
                const latestDateStr = modelData.daily_assets[modelData.daily_assets.length - 1].date;
                const latestDateIndex = allDates.indexOf(latestDateStr);
                
                if (latestDateIndex < 0) return null;
                
                return {
                    name: `${model.name}_ripple`,
                    type: 'effectScatter',
                    coordinateSystem: 'cartesian2d',
                    data: [[latestDateIndex, latestAssets]],
                    symbolSize: 28,  // æ³¢çº¹èµ·å§‹å¤§å°
                    showEffectOn: 'render',
                    rippleEffect: {
                        period: 3.5,  // æ€»å‘¨æœŸ3.5ç§’ï¼ˆ1ç§’æ‰©æ•£+2.5ç§’åœé¡¿ï¼‰
                        scale: 2.5,  // æ”¾å¤§å€æ•°
                        brushType: 'stroke',  // çº¿åœˆå¼æ³¢çº¹
                        number: 1,  // ä¸€æ¬¡åªæ˜¾ç¤º1ä¸ªæ³¢çº¹ï¼Œå®ç°é—´æ­‡æ•ˆæœ
                        color: model.color  // æ³¢çº¹é¢œè‰²
                    },
                    itemStyle: {
                        color: model.color,
                        opacity: 0  // ä¸­å¿ƒç‚¹é€æ˜
                    },
                    zlevel: 0,  // åœ¨åº•å±‚
                    z: 0,
                    silent: true
                };
            }).filter(s => s !== null);
            
            const option = {
                animation: replayState.isPlaying ? false : true,  // å›æ”¾æ—¶ç¦ç”¨åŠ¨ç”»ï¼Œæ­£å¸¸æ—¶å¯ç”¨
                animationDuration: 0,  // åˆå§‹æ¸²æŸ“æ— åŠ¨ç”»
                animationDurationUpdate: replayState.isPlaying ? 0 : 200,  // å›æ”¾æ—¶æ— åŠ¨ç”»ï¼Œæ­£å¸¸æ—¶200ms
                animationEasing: 'cubicOut',
                tooltip: {
                    trigger: 'axis',
                    triggerOn: 'mousemove',
                    axisPointer: {
                        type: 'line',
                        snap: true,
                        lineStyle: {
                            color: '#999',
                            width: 1,
                            type: 'dashed'
                        },
                        label: {
                            show: false
                        }
                    },
                    confine: true,
                    transitionDuration: 0.2,
                    hideDelay: 100,
                    enterable: false,
                    formatter: function(params) {
                        // è·å–æ—¥æœŸç´¢å¼•
                        const dateIndex = params[0].dataIndex;
                        if (!allDates[dateIndex]) return '';  // ç©ºç™½æ—¥æœŸä¸æ˜¾ç¤º
                        
                        const dateStr = allDates[dateIndex];
                        const formatted = `${dateStr.substr(0,4)}-${dateStr.substr(4,2)}-${dateStr.substr(6,2)}`;
                        
                        let result = formatted + '<br/>';
                        let hasData = false;
                        params.forEach(p => {
                            // è¿‡æ»¤æ‰rippleç³»åˆ—å’Œåˆå§‹èµ„é‡‘çº¿
                            if (p.seriesName !== 'åˆå§‹èµ„é‡‘' && 
                                !p.seriesName.includes('_ripple') && 
                                p.value !== null && 
                                p.value !== undefined) {
                                result += `${p.marker} ${p.seriesName}: Â¥${p.value.toLocaleString()}<br/>`;
                                hasData = true;
                            }
                        });
                        return hasData ? result : '';  // æ²¡æœ‰æ•°æ®ä¸æ˜¾ç¤ºtooltip
                    }
                },
                legend: {
                    data: config.models.map(m => m.name),
                    top: 10,
                    selected: config.models.reduce((obj, m) => {
                        obj[m.name] = true;
                        return obj;
                    }, {})
                },
                grid: {
                    left: '3%',
                    right: '15%',  // å³ä¾§ç•™ç©ºé—´ç»™æœ«ç«¯æ ‡ç­¾
                    bottom: '3%',
                    containLabel: true
                },
                xAxis: {
                    type: 'category',
                    data: xAxisLabels,
                    boundaryGap: false,
                    min: undefined,  // æ˜ç¡®ç§»é™¤å›ºå®šèŒƒå›´ï¼Œæ¢å¤è‡ªé€‚åº”
                    max: undefined,  // æ˜ç¡®ç§»é™¤å›ºå®šèŒƒå›´ï¼Œæ¢å¤è‡ªé€‚åº”
                    axisLabel: {
                        interval: 'auto'
                    },
                    axisPointer: {
                        show: true
                    }
                },
                yAxis: {
                    type: 'value',
                    name: 'èµ„äº§(å…ƒ)',
                    min: yMin,
                    max: yMax,
                    axisLabel: {
                        formatter: value => `Â¥${value.toLocaleString()}`
                    },
                    splitLine: {
                        lineStyle: {
                            type: 'dashed',
                            color: '#e0e0e0'
                        }
                    }
                },
                // æ·»åŠ åˆå§‹èµ„é‡‘å‚è€ƒçº¿å’Œæ³¢çº¹æ•ˆæœ
                series: [
                    ...series,  // æ›²çº¿å’ŒmarkPointï¼ˆzlevel=1ï¼‰
                    ...rippleEffects,  // æ³¢çº¹ï¼ˆzlevel=0ï¼‰
                    {
                        name: 'åˆå§‹èµ„é‡‘',
                        type: 'line',
                        silent: true,  // ä¸å“åº”é¼ æ ‡äº‹ä»¶
                        emphasis: {
                            disabled: true  // ç¦ç”¨é«˜äº®
                        },
                        blur: {
                            lineStyle: {
                                opacity: 1  // å§‹ç»ˆä¿æŒä¸é€æ˜
                            }
                        },
                        markLine: {
                            silent: true,
                            symbol: 'none',
                            label: {
                                show: true,
                                position: 'insideEndTop',
                                formatter: function(params) {
                                    return `åˆå§‹: Â¥${params.value.toLocaleString()}`;
                                },
                                color: '#666',
                                fontSize: 11
                            },
                            lineStyle: {
                                color: '#ff9800',
                                type: 'dashed',
                                width: 2
                            },
                            data: [{
                                yAxis: initialCapital
                            }]
                        },
                        data: []
                    }
                ]
            };
            
            // âœ… å›æ”¾æ—¶å¼ºåˆ¶æ›¿æ¢seriesï¼ˆæ¸…é™¤æ³¢çº¹ï¼‰ï¼Œæ­£å¸¸æ¨¡å¼ç”¨merge
            const setOptionConfig = replayState.isPlaying 
                ? { replaceMerge: ['series'] }  // å¼ºåˆ¶æ›¿æ¢æ‰€æœ‰seriesï¼Œæ¸…é™¤æ—§çš„effectScatter
                : {};  // æ­£å¸¸merge
            
            chart.setOption(option, setOptionConfig);
            chart.resize();  // é‡æ–°è°ƒæ•´å›¾è¡¨å¤§å°ä»¥é€‚åº”æ–°é«˜åº¦
            
            // âœ… ä¿å­˜ä¹‹å‰çš„é«˜äº®çŠ¶æ€
            const wasHighlighted = highlightedModel;
            
            // æ‰‹åŠ¨æ§åˆ¶æ‚¬åœæ•ˆæœ
            chart.off('mouseover');
            chart.off('mouseout');
            chart.off('mousemove');
            
            let currentHoverIndex = null;
            let hoverTimeout = null;
            
            // ç»Ÿä¸€çš„é«˜äº®å¤„ç†å‡½æ•°
            function highlightSeries(hoverIndex) {
                if (currentHoverIndex === hoverIndex) return;
                
                const option = chart.getOption();
                
                // åŠ ç²—å½“å‰æ›²çº¿å’Œå›¾æ ‡ï¼Œå…¶ä»–å˜é€æ˜
                option.series.forEach((s, idx) => {
                    if (s.name !== 'åˆå§‹èµ„é‡‘' && !s.name.includes('_ripple')) {
                        if (idx === hoverIndex) {
                            s.lineStyle = { 
                                width: 4, 
                                color: s.lineStyle.color,
                                opacity: 1
                            };
                            // markPointå›¾æ ‡ä¿æŒä¸é€æ˜
                            if (s.markPoint && s.markPoint.data) {
                                s.markPoint.data.forEach(point => {
                                    if (point.itemStyle) {
                                        point.itemStyle.opacity = 1;
                                    }
                                });
                            }
                        } else {
                            s.lineStyle = { 
                                width: 2, 
                                color: s.lineStyle.color,
                                opacity: 0.3
                            };
                            // markPointå›¾æ ‡ä¹Ÿå˜æ·¡
                            if (s.markPoint && s.markPoint.data) {
                                s.markPoint.data.forEach(point => {
                                    if (point.itemStyle) {
                                        point.itemStyle.opacity = 0.3;
                                    }
                                });
                            }
                        }
                    }
                });
                
                chart.setOption(option, { notMerge: false, lazyUpdate: true, silent: true });
                currentHoverIndex = hoverIndex;
            }
            
            // ç»Ÿä¸€çš„æ¢å¤å‡½æ•°
            function restoreAllSeries() {
                if (currentHoverIndex === null) return;
                
                const option = chart.getOption();
                
                // æ¢å¤æ‰€æœ‰æ›²çº¿å’Œå›¾æ ‡
                option.series.forEach((s, idx) => {
                    if (s.name !== 'åˆå§‹èµ„é‡‘' && !s.name.includes('_ripple')) {
                        s.lineStyle = { 
                            width: 2, 
                            color: s.lineStyle.color,
                            opacity: 1
                        };
                        // æ¢å¤markPointå›¾æ ‡é€æ˜åº¦
                        if (s.markPoint && s.markPoint.data) {
                            s.markPoint.data.forEach(point => {
                                if (point.itemStyle) {
                                    point.itemStyle.opacity = 1;
                                }
                            });
                        }
                    }
                });
                
                chart.setOption(option, { notMerge: false, lazyUpdate: true, silent: true });
                currentHoverIndex = null;
            }
            
            // ä½¿ç”¨mousemoveæ›´ç¨³å®š
            chart.on('mousemove', function(params) {
                if (highlightedModel !== null) return;
                
                // æ¸…é™¤ä¹‹å‰çš„è¶…æ—¶
                if (hoverTimeout) {
                    clearTimeout(hoverTimeout);
                    hoverTimeout = null;
                }
                
                // åœ¨seriesæˆ–markPointä¸Š
                if ((params.componentType === 'series' || params.componentType === 'markPoint') && 
                    params.seriesName !== 'åˆå§‹èµ„é‡‘') {
                    highlightSeries(params.seriesIndex);
                } else {
                    // ä¸åœ¨ä»»ä½•seriesä¸Šï¼Œå»¶è¿Ÿæ¢å¤
                    hoverTimeout = setTimeout(() => {
                        restoreAllSeries();
                    }, 50);
                }
            });
            
            // ç›‘å¬é¼ æ ‡ç¦»å¼€å›¾è¡¨åŒºåŸŸ
            chart.getZr().on('mouseout', function() {
                if (highlightedModel !== null) return;
                restoreAllSeries();
            });
            
            // âœ… æ¢å¤ä¹‹å‰çš„é«˜äº®çŠ¶æ€ï¼ˆå¦‚æœæœ‰ï¼‰
            if (wasHighlighted) {
                // å»¶è¿Ÿä¸€å¸§æ‰§è¡Œï¼Œç¡®ä¿äº‹ä»¶ç›‘å¬å™¨å·²ç»‘å®š
                setTimeout(() => {
                    toggleModelHighlight(wasHighlighted, null);
                }, 50);
            }
        }
        
        // âœ… æ’åå·²åˆå¹¶åˆ°æ¨¡å‹å¡ç‰‡ï¼Œæ­¤å‡½æ•°ä¸å†ä½¿ç”¨
        // function updateRankings(rankings) { ... }
        
        // æ›´æ–°äº¤æ˜“è®°å½•ï¼ˆå¡ç‰‡å¼æ—¶é—´çº¿ï¼‰
        function updateTradesTable(data) {
            const trades = [];
            
            // åˆå¹¶æ‰€æœ‰æ¨¡å‹çš„äº¤æ˜“è®°å½•
            Object.keys(data).forEach(modelKey => {
                const modelData = data[modelKey];
                // âœ… é€šè¿‡idæˆ–nameæ‰¾åˆ°å¯¹åº”çš„æ¨¡å‹é…ç½®ï¼Œè·å–æ˜¾ç¤ºåç§°
                const modelConfig = config.models.find(m => m.id === modelKey || m.name === modelKey);
                const displayName = modelConfig ? modelConfig.name : modelKey;
                
                if (modelData.trade_history) {
                    modelData.trade_history.forEach(trade => {
                        trades.push({
                            model: displayName,  // âœ… ä½¿ç”¨æ˜¾ç¤ºåç§°è€Œä¸æ˜¯key
                            color: modelData.model_color,
                            ...trade
                        });
                    });
                }
            });
            
            // æŒ‰æ—¥æœŸå’Œæ—¶é—´å€’åºæ’åºï¼ˆæœ€æ–°çš„åœ¨ä¸Šé¢ï¼‰
            trades.sort((a, b) => {
                // å…ˆæŒ‰æ—¥æœŸæ¯”è¾ƒ
                const dateCompare = b.date.localeCompare(a.date);
                if (dateCompare !== 0) return dateCompare;
                
                // æ—¥æœŸç›¸åŒæ—¶ï¼ŒæŒ‰æ—¶é—´æ¯”è¾ƒï¼ˆæœ‰æ—¶é—´çš„ä¼˜å…ˆï¼Œæ—¶é—´æ™šçš„åœ¨å‰ï¼‰
                const timeA = a.time || '00:00:00';
                const timeB = b.time || '00:00:00';
                return timeB.localeCompare(timeA);
            });
            
            // æ›´æ–°å³ä¾§Tab
            const container = document.getElementById('tradesTableRight');
            if (container) {
                if (trades.length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-400 text-xs py-4">æš‚æ— äº¤æ˜“è®°å½•</div>';
                    return;
                }
                
                container.innerHTML = trades.slice(0, 30).map(t => {
                    const isBuy = t.action === 'buy';
                    const actionText = isBuy ? 'ä¹°å…¥' : 'å–å‡º';
                    
                    // æ ¼å¼åŒ–æ—¥æœŸå’Œæ—¶é—´
                    const dateStr = `${t.date.substr(0,4)}å¹´${t.date.substr(4,2)}æœˆ${t.date.substr(6,2)}æ—¥`;
                    const timeStr = t.time ? ` ${t.time}` : '';
                    const dateTimeStr = dateStr + timeStr;
                    
                    // è®¡ç®—ç›ˆäºï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰- å–å‡ºæ—¶æ˜¾ç¤ºï¼Œæ’é™¤nullå€¼
                    const profitHtml = (t.profit !== undefined && t.profit !== null) ? `
                        <div class="mt-2 pt-2 border-t border-gray-300">
                            <div class="flex justify-between items-center">
                                <span class="text-xs font-medium text-gray-600">ğŸ’° å‡€æŸç›Š:</span>
                                <span class="text-sm font-bold ${t.profit >= 0 ? 'text-red-600' : 'text-green-600'}">
                                    ${t.profit >= 0 ? '+' : ''}Â¥${t.profit.toFixed(2)}
                                    ${(t.profit_pct !== undefined && t.profit_pct !== null) ? `
                                        <span class="text-xs ml-1">
                                            (${t.profit_pct >= 0 ? '+' : ''}${t.profit_pct.toFixed(2)}%)
                                        </span>
                                    ` : ''}
                                </span>
                            </div>
                        </div>
                    ` : '';
                    
                    // è·å–æ¨¡å‹logo
                    const model = config.models.find(m => m.name === t.model);
                    const logoHtml = model?.logo ? `<img src="${model.logo}" class="w-4 h-4 inline-block" />` : '';
                    
                    return `
                        <div class="mb-2 p-2 bg-gray-50 rounded border-l-3" style="border-left: 3px solid ${t.color}">
                            <div class="flex justify-between items-start mb-1">
                                <div class="flex items-center gap-1">
                                    ${logoHtml}
                                    <span class="font-bold text-xs" style="color: ${t.color}">${t.model}</span>
                                    <span class="text-xs ${isBuy ? 'text-red-600' : 'text-green-600'}">${actionText}</span>
                                    <span class="text-xs font-bold">${t.name || 'æœªçŸ¥'}</span>
                                </div>
                                <span class="text-xs text-gray-400">${dateTimeStr}</span>
                            </div>
                            <div class="text-xs text-gray-600">
                                <div>ä»£ç : ${t.code} | åç§°: ${t.name || 'æœªçŸ¥'}</div>
                                <div>ä»·æ ¼: Â¥${t.price != null ? t.price.toFixed(2) : 'N/A'}</div>
                                <div>æ•°é‡: ${t.amount != null ? t.amount : 'N/A'}</div>
                                <div>æ€»é¢: Â¥${t.total != null ? t.total.toFixed(2) : 'N/A'}</div>
                                ${(t.commission != null) ? `<div>æ‰‹ç»­è´¹: Â¥${t.commission.toFixed(2)}</div>` : ''}
                                ${profitHtml}
                            </div>
                            ${t.reason ? `<div class="mt-1 text-xs text-gray-500 italic">${t.reason}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }
        }
        
        // æ›´æ–°æŒä»“è¡¨ï¼ˆæŒ‰æ¨¡å‹åˆ†ç»„çš„å¡ç‰‡å¼ï¼‰
        function updateHoldingsTable(data) {
            const container = document.getElementById('holdingsTableRight');
            if (!container) return;
            
            // æŒ‰æ¨¡å‹åˆ†ç»„
            const modelGroups = [];
            Object.keys(data).forEach(modelKey => {
                const modelData = data[modelKey];
                // âœ… é€šè¿‡idæˆ–nameæ‰¾åˆ°å¯¹åº”çš„æ¨¡å‹é…ç½®ï¼Œè·å–æ˜¾ç¤ºåç§°
                const modelConfig = config.models.find(m => m.id === modelKey || m.name === modelKey);
                const displayName = modelConfig ? modelConfig.name : modelKey;
                
                // âœ… å…¼å®¹æ•°ç»„å’Œå¯¹è±¡æ ¼å¼çš„holdings
                const holdings = Array.isArray(modelData.holdings) 
                    ? modelData.holdings 
                    : (modelData.holdings ? Object.values(modelData.holdings) : []);
                
                if (holdings && holdings.length > 0) {
                    
                    // è®¡ç®—æ€»ç›ˆäº
                    const totalProfit = holdings.reduce((sum, h) => {
                        return sum + (h.current_price - h.cost) * h.amount;
                    }, 0);
                    
                    const totalValue = holdings.reduce((sum, h) => sum + h.current_price * h.amount, 0);
                    const totalCost = holdings.reduce((sum, h) => sum + h.cost * h.amount, 0);
                    const totalProfitPct = ((totalValue - totalCost) / totalCost) * 100;
                    
                    modelGroups.push({
                        modelName: displayName,  // âœ… ä½¿ç”¨æ˜¾ç¤ºåç§°
                        modelConfig: modelConfig,  // âœ… ä¿å­˜æ¨¡å‹é…ç½®ä»¥ä¾¿åç»­ä½¿ç”¨
                        color: modelData.model_color,
                        holdings,
                        totalProfit,
                        totalProfitPct
                    });
                }
            });
            
            if (modelGroups.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-400 text-xs py-4">æš‚æ— æŒä»“</div>';
                return;
            }
            
            // æ¸²æŸ“åˆ†ç»„å¡ç‰‡
            container.innerHTML = modelGroups.map(group => {
                // è·å–æ¨¡å‹logoï¼ˆä»ä¿å­˜çš„modelConfigè·å–ï¼‰
                const model = group.modelConfig;
                const logoHtml = model?.logo ? `<img src="${model.logo}" class="w-5 h-5 inline-block mr-1" />` : '';
                
                return `
                <div class="mb-4 bg-gray-50 rounded p-2" style="border-left: 3px solid ${group.color}">
                    <div class="flex justify-between items-center mb-2 pb-2 border-b">
                        <div class="flex items-center">
                            ${logoHtml}
                            <span class="font-bold text-sm" style="color: ${group.color}">${group.modelName}</span>
                        </div>
                        <span class="text-xs font-bold ${group.totalProfitPct >= 0 ? 'text-red-600' : 'text-green-600'}">
                            ${group.totalProfitPct >= 0 ? '+' : ''}${group.totalProfitPct.toFixed(2)}% (${group.totalProfitPct >= 0 ? '+' : ''}Â¥${group.totalProfit.toFixed(2)})
                        </span>
                    </div>
                    ${group.holdings.map(h => {
                        // ä¿®å¤ï¼šç›´æ¥ä»hå¯¹è±¡è·å–è‚¡ç¥¨ä»£ç å’Œåç§°
                        const stockCode = h.code || h.stock_code || '';
                        const stockName = h.name || h.stock_name || stockCode;
                        
                        // è®¡ç®—æ€»ä»·å’Œç›ˆäº
                        const totalValue = h.current_price * h.amount;  // æ€»ä»·
                        const totalCost = h.cost * h.amount;  // æ€»æˆæœ¬
                        const profit = totalValue - totalCost;  // ç›ˆäºé‡‘é¢

                        return `
                        <div class="flex justify-between items-center py-1 text-xs border-b border-gray-200">
                            <div class="flex-1">
                                <div class="font-medium">${stockName}</div>
                                <div class="text-gray-500">${stockCode} | æŒä»“: ${h.amount} | æˆæœ¬: Â¥${h.cost.toFixed(2)}</div>
                            </div>
                            <div class="text-right">
                                <div class="font-medium">Â¥${h.current_price.toFixed(2)}</div>
                                <div class="text-gray-600">æ€»ä»·: Â¥${totalValue.toFixed(2)}</div>
                                <div class="${profit >= 0 ? 'text-red-600' : 'text-green-600'}">
                                    ${profit >= 0 ? '+' : ''}Â¥${profit.toFixed(2)} (${h.profit_pct >= 0 ? '+' : ''}${h.profit_pct.toFixed(2)}%)
                                </div>
                            </div>
                        </div>
                        `;
                    }).join('')}
                </div>
            `;
            }).join('');
        }
        
        // æ›´æ–°AIæ—¥å¿—ï¼ˆå¢é‡ï¼‰
        async function updateAILogs() {
            try {
                const allLogs = [];
                
                // è·å–æ‰€æœ‰æ¨¡å‹çš„æ—¥å¿—
                for (const model of config.models) {
                    try {
                        const res = await fetch(`${API_BASE}/api/arena/logs/${model.name}?limit=20`);
                        const data = await res.json();
                        if (data.logs && data.logs.length > 0) {
                            allLogs.push(...data.logs.map(log => ({
                                ...log,
                                color: model.color
                            })));
                        }
                    } catch (error) {
                        console.error(`âŒ è·å–${model.name}æ—¥å¿—å¤±è´¥:`, error);
                    }
                }
                
                // æŒ‰æ—¶é—´å€’åºæ’åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
                allLogs.sort((a, b) => b.timestamp.localeCompare(a.timestamp));
                
                // åªæ˜¾ç¤ºæœ€æ–°çš„50æ¡
                const logs = allLogs.slice(0, 50);
                
                if (logs.length === 0) return;
                
                const container = document.getElementById('aiLogs');
                
                // âœ… è®¡ç®—æ—¥å¿—å†…å®¹çš„hashï¼Œåˆ¤æ–­æ˜¯å¦çœŸçš„æœ‰å˜åŒ–
                const logsHash = logs.map(l => l.timestamp + l.message).join('|');
                if (logsHash !== lastLogsHash) {
                    container.innerHTML = logs.map(log => {
                        const type = log.type || 'info';
                        
                        // âœ… æ˜¾ç¤ºlogoï¼Œæ¶ˆæ¯é‡Œå·²ç»åŒ…å«æ¨¡å‹åå’Œæ—¶é—´
                        const model = config.models.find(m => m.name === log.model_name);
                        const logoHtml = model?.logo ? `<img src="${model.logo}" class="w-5 h-5 inline-block mr-2" />` : '';
                        
                        return `
                            <div class="log-entry log-${type} flex items-start gap-2">
                                ${logoHtml}
                                <div class="flex-1">${log.message}</div>
                            </div>
                        `;
                    }).join('');
                    
                    // ä¿æŒåœ¨é¡¶éƒ¨ï¼ˆæœ€æ–°æ¶ˆæ¯åœ¨ä¸Šï¼‰
                    container.scrollTop = 0;
                    lastLogsHash = logsHash;  // ä¿å­˜æ–°çš„hash
                }
            } catch (error) {
                console.error('æ›´æ–°AIæ—¥å¿—å¤±è´¥:', error);
            }
        }
        
        // Tabåˆ‡æ¢
        function switchTab(tabName) {
            // éšè—æ‰€æœ‰tabå†…å®¹
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            
            // ç§»é™¤æ‰€æœ‰æŒ‰é’®çš„activeçŠ¶æ€
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // æ˜¾ç¤ºé€‰ä¸­çš„tabï¼ˆä½¿ç”¨blockå¸ƒå±€ï¼‰
            document.getElementById(`tab-${tabName}`).style.display = 'block';
            
            // æ¿€æ´»å¯¹åº”æŒ‰é’®
            event.target.classList.add('active');
        }
        
        // å®šæ—¶è½®è¯¢
        let aiLogsIntervalId = null;  // AIæ—¥å¿—è½®è¯¢IDï¼ˆç‹¬ç«‹ï¼‰
        
        function startPolling() {
            updateUI();
            replayState.normalUpdateIntervalId = setInterval(updateUI, 3000);  // âœ… ä¼˜åŒ–ï¼šä»10ç§’æ”¹ä¸º3ç§’ï¼Œæå‡æ›´æ–°é¢‘ç‡
            
            // âœ… AIæ—¥å¿—å•ç‹¬è½®è¯¢ï¼Œæ›´é¢‘ç¹ï¼ˆ2ç§’ï¼‰
            if (!aiLogsIntervalId) {
                aiLogsIntervalId = setInterval(updateAILogs, 2000);
            }
        }
        
        // åœæ­¢æ­£å¸¸è½®è¯¢
        function stopPolling() {
            if (replayState.normalUpdateIntervalId) {
                clearInterval(replayState.normalUpdateIntervalId);
                replayState.normalUpdateIntervalId = null;
            }
            
            // âœ… åœæ­¢AIæ—¥å¿—è½®è¯¢
            if (aiLogsIntervalId) {
                clearInterval(aiLogsIntervalId);
                aiLogsIntervalId = null;
            }
        }
        
        // å›æ”¾ï¼šåˆ‡æ¢æ’­æ”¾/åœæ­¢
        async function toggleReplay() {
            if (replayState.isPlaying) {
                await stopReplay();
            } else {
                await startReplay();
            }
        }
        
        // å¼€å§‹å›æ”¾
        async function startReplay() {
            const btn = document.getElementById('replayBtn');
            
            // âœ… æ˜¾ç¤ºåŠ è½½æç¤ºï¼ˆæ”¾åœ¨æœ€å‰é¢ï¼‰
            btn.textContent = 'â³ åŠ è½½ä¸­...';
            btn.disabled = true;
            btn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
            btn.classList.add('bg-red-500', 'hover:bg-red-600');
            
            // åœæ­¢è½®è¯¢ï¼Œç”±å›æ”¾å®Œå…¨æ§åˆ¶æ¸²æŸ“
            stopPolling();
            
            // è®¾ç½®å›æ”¾æ¨¡å¼ï¼ˆéšè—æ³¢çº¹ï¼‰
            replayState.isReplayMode = true;
            
            // ä¿å­˜å½“å‰å›¾è¡¨çš„åæ ‡è½´é…ç½®ï¼ˆç”¨äºå›æ”¾æ—¶ä¿æŒä¸€è‡´ï¼‰
            const currentOption = chart.getOption();
            replayState.savedAxisConfig = {
                xAxisLabels: currentOption.xAxis[0].data,
                yMin: currentOption.yAxis[0].min,
                yMax: currentOption.yAxis[0].max,
                initialCapital: config.initial_capital || 10000
            };
            
            // è·å–å®Œæ•´æ•°æ®
            if (!replayState.fullData) {
                try {
                    console.log('ğŸ“¥ æ­£åœ¨è·å–å†å²æ•°æ®...');
                    const response = await fetch(`${API_BASE}/api/arena/data`);
                    replayState.fullData = await response.json();
                    console.log('âœ… å†å²æ•°æ®åŠ è½½å®Œæˆ');
                } catch (error) {
                    console.error('è·å–å›æ”¾æ•°æ®å¤±è´¥:', error);
                    replayState.isReplayMode = false;  // æ¢å¤æ­£å¸¸æ¨¡å¼
                    btn.textContent = 'â¯ï¸ å›æ”¾';
                    btn.disabled = false;
                    btn.classList.remove('bg-red-500', 'hover:bg-red-600');
                    btn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                    startPolling();
                    return;
                }
            }
            
            // âœ… æ¢å¤æŒ‰é’®çŠ¶æ€
            btn.disabled = false;
            
            // åˆå§‹åŒ–å›¾è¡¨é…ç½®ï¼ˆä¸æ¸…é™¤seriesï¼Œç»Ÿä¸€ç”¨updateChartæ¸²æŸ“ï¼‰
            initReplayChart();
            
            // åªè®¾ç½®å›ºå®šçš„æ¨ªè½´å’Œçºµè½´é…ç½®
            chart.setOption({
                tooltip: {
                    trigger: 'axis',
                    formatter: function(params) {
                        const dateIndex = params[0].dataIndex;
                        const dateStr = replayState.allDates[dateIndex];
                        const formatted = `${dateStr.substr(0,4)}-${dateStr.substr(4,2)}-${dateStr.substr(6,2)}`;
                        
                        let result = formatted + '<br/>';
                        params.forEach(p => {
                            // è¿‡æ»¤æ‰rippleç³»åˆ—å’Œåˆå§‹èµ„é‡‘çº¿
                            if (p.seriesName !== 'åˆå§‹èµ„é‡‘' && 
                                !p.seriesName.includes('_ripple') && 
                                p.value !== null && 
                                p.value !== undefined) {
                                result += `${p.marker} ${p.seriesName}: Â¥${p.value.toLocaleString()}<br/>`;
                            }
                        });
                        return result;
                    }
                },
                legend: {
                    data: config.models.map(m => m.name),
                    top: 10
                },
                grid: {
                    left: '3%',
                    right: '15%',
                    bottom: '3%',
                    containLabel: true
                },
                xAxis: {
                    type: 'category',
                    data: replayState.fixedAxisConfig.xAxisLabels,
                    boundaryGap: false,
                    min: 0,
                    max: replayState.fixedAxisConfig.xAxisLabels.length - 1,
                    axisLabel: {
                        interval: 'auto'
                    }
                },
                yAxis: {
                    type: 'value',
                    name: 'èµ„äº§(å…ƒ)',
                    min: replayState.fixedAxisConfig.yMin,
                    max: replayState.fixedAxisConfig.yMax,
                    axisLabel: {
                        formatter: value => `Â¥${value.toLocaleString()}`
                    },
                    splitLine: {
                        lineStyle: {
                            type: 'dashed',
                            color: '#e0e0e0'
                        }
                    }
                }
            });  // ä½¿ç”¨é»˜è®¤mergeæ¨¡å¼
            
            // é‡ç½®èµ„äº§å¡ç‰‡ä¸ºåˆå§‹å€¼
            const initialCapital = config.initial_capital || 10000;
            config.models.forEach(model => {
                const assetEl = document.getElementById(`asset-${model.name}`);
                const profitEl = document.getElementById(`profit-${model.name}`);
                if (assetEl && profitEl) {
                    assetEl.textContent = `Â¥${initialCapital.toLocaleString()}`;
                    profitEl.textContent = '0.00%';
                    profitEl.className = 'text-sm font-medium text-gray-600';
                }
            });
            
            // å¼€å§‹æ’­æ”¾
            replayState.isPlaying = true;
            replayState.currentIndex = 0;
            replayState.currentSubStep = 0;
            
            // âœ… ç«‹å³æ¸²æŸ“ä¸€æ¬¡åˆå§‹çŠ¶æ€ï¼ˆæ¸…é™¤æ³¢çº¹ï¼Œæ˜¾ç¤ºç¬¬ä¸€å¤©æ•°æ®ï¼‰
            const initialReplayData = {};
            Object.keys(replayState.fullData).forEach(modelName => {
                const modelData = replayState.fullData[modelName];
                const firstDay = modelData.daily_assets && modelData.daily_assets.length > 0 
                    ? [modelData.daily_assets[0]]  // åªå–ç¬¬ä¸€å¤©
                    : [];
                initialReplayData[modelName] = {
                    ...modelData,
                    daily_assets: firstDay
                };
            });
            console.log('ğŸ¬ å¼€å§‹å›æ”¾ï¼Œæ¸…é™¤æ³¢çº¹å¹¶æ˜¾ç¤ºç¬¬ä¸€å¤©');
            updateChart(initialReplayData);  // è§¦å‘updateChartï¼Œæ­¤æ—¶isPlaying=trueä¼šæ¸…é™¤æ³¢çº¹
            
            // âœ… åŠ¨æ€è®¡ç®—é€Ÿåº¦ï¼šæ€»æ—¶é•¿ / (æ€»å¤©æ•° * æ’å€¼æ­¥æ•°)
            const totalDays = replayState.allDates.length - 3;  // -3å› ä¸ºæœ‰3ä¸ªç©ºç™½æ—¥æœŸ
            const totalFrames = totalDays * replayState.interpolationSteps;
            replayState.speed = Math.max(30, Math.floor(replayState.totalDuration / totalFrames));  // æœ€å°30ms
            const actualDuration = (replayState.speed * totalFrames / 1000).toFixed(1);
            console.log(`ğŸ“º å›æ”¾é…ç½®: ${totalDays}å¤©, ${replayState.interpolationSteps}å€æ’å€¼, ${totalFrames}å¸§, ${replayState.speed}ms/å¸§, æ€»æ—¶é•¿${actualDuration}ç§’`);
            
            // æ›´æ–°æŒ‰é’®æ–‡å­—æ˜¾ç¤ºé¢„è®¡æ—¶é•¿
            btn.textContent = `â¸ï¸ åœæ­¢ (${actualDuration}s)`;
            
            replayState.intervalId = setInterval(() => {
                // âœ… æ£€æŸ¥æ˜¯å¦å·²åœæ­¢ï¼ˆé˜²æ­¢clearIntervalå»¶è¿Ÿï¼‰
                if (!replayState.isPlaying) {
                    console.log('âš ï¸ æ£€æµ‹åˆ°å·²åœæ­¢ï¼Œé€€å‡ºå›è°ƒ');
                    return;
                }
                
                // âœ… è®¡ç®—æ’å€¼æ¯”ä¾‹ (0.0 - 1.0)
                const t = replayState.currentSubStep / replayState.interpolationSteps;
                
                // âœ… æ„é€ æ’å€¼åçš„æ•°æ®ï¼ˆå…³é”®ï¼šä¿æŒå®Œæ•´é•¿åº¦ï¼Œæœªåˆ°è¾¾çš„ç”¨nullï¼‰
                const replayData = {};
                Object.keys(replayState.fullData).forEach(modelName => {
                    const modelData = replayState.fullData[modelName];
                    const assets = modelData.daily_assets || [];
                    
                    // âœ… åˆ›å»ºå®Œæ•´é•¿åº¦çš„æ•°ç»„ï¼ˆä¸allDatesä¸€è‡´ï¼‰
                    const interpolatedAssets = [];
                    
                    for (let i = 0; i < replayState.allDates.length - 3; i++) {  // -3å› ä¸ºæœ‰3ä¸ªç©ºç™½æ—¥æœŸ
                        const dateStr = replayState.allDates[i];
                        
                        if (i < replayState.currentIndex) {
                            // å·²æ’­æ”¾çš„å¤©ï¼Œç›´æ¥ç”¨åŸæ•°æ®
                            if (assets[i]) {
                                interpolatedAssets.push(assets[i]);
                            }
                            // âœ… å¦‚æœæ²¡æœ‰æ•°æ®å°±è·³è¿‡ï¼Œä¸pushï¼ˆè®©dateMapæ„é€ æ—¶è‡ªåŠ¨ä¸ºnullï¼‰
                        } else if (i === replayState.currentIndex) {
                            // å½“å‰æ­£åœ¨æ’­æ”¾çš„å¤©ï¼Œåšæ’å€¼
                            const current = assets[i];
                            const next = assets[i + 1];
                            if (current && next && t > 0) {
                                // çº¿æ€§æ’å€¼total_assets
                                const interpolatedValue = current.total_assets + (next.total_assets - current.total_assets) * t;
                                interpolatedAssets.push({
                                    date: dateStr,
                                    total_assets: interpolatedValue
                                });
                            } else if (current) {
                                interpolatedAssets.push(current);
                            }
                            // âœ… å¦‚æœæ²¡æœ‰æ•°æ®å°±è·³è¿‡
                        }
                        // âœ… æœªåˆ°è¾¾çš„å¤©ï¼Œä¸pushä»»ä½•æ•°æ®ï¼ˆè®©å®ƒä»¬åœ¨å›¾è¡¨ä¸Šæ˜¾ç¤ºä¸ºç©ºï¼‰
                    }
                    
                    replayData[modelName] = {
                        ...modelData,
                        daily_assets: interpolatedAssets
                    };
                });
                
                // âœ… ç›´æ¥è°ƒç”¨updateChartï¼Œç»Ÿä¸€æ¸²æŸ“é€»è¾‘ï¼
                updateChart(replayData);
                
                // æ›´æ–°è¿›åº¦æ¡
                const currentDate = replayState.allDates[replayState.currentIndex];
                const formatted = `${currentDate.substr(0,4)}-${currentDate.substr(4,2)}-${currentDate.substr(6,2)}`;
                const totalDaysForProgress = replayState.allDates.length - 3;  // æ’é™¤ç©ºç™½æ—¥æœŸ
                const totalFramesForProgress = totalDaysForProgress * replayState.interpolationSteps;
                const percent = Math.floor(((replayState.currentIndex * replayState.interpolationSteps + replayState.currentSubStep) / totalFramesForProgress) * 100);
                document.getElementById('progressText').textContent = `â¯ï¸ å›æ”¾ä¸­: ${formatted}`;
                document.getElementById('progressPercent').textContent = `${percent}%`;
                document.getElementById('progressBar').style.width = `${percent}%`;
                
                // æ¨è¿›å­æ­¥éª¤
                replayState.currentSubStep++;
                if (replayState.currentSubStep >= replayState.interpolationSteps) {
                    replayState.currentSubStep = 0;
                    replayState.currentIndex++;
                }
                
                // æ£€æŸ¥æ˜¯å¦æ’­æ”¾å®Œæˆï¼ˆ-3å› ä¸ºæœ‰3ä¸ªç©ºç™½æ—¥æœŸï¼‰
                if (replayState.currentIndex >= replayState.allDates.length - 3) {
                    console.log('âœ… å›æ”¾å®Œæˆï¼Œè‡ªåŠ¨åœæ­¢');
                    stopReplay();
                }
            }, replayState.speed);
        }
        
        // åœæ­¢å›æ”¾
        async function stopReplay() {
            console.log('ğŸ›‘ åœæ­¢å›æ”¾: intervalId=', replayState.intervalId);
            
            // ç«‹å³æ¸…é™¤å®šæ—¶å™¨ï¼ˆå…³é”®ï¼šå¿…é¡»å…ˆæ¸…é™¤ï¼‰
            if (replayState.intervalId) {
                clearInterval(replayState.intervalId);
                replayState.intervalId = null;
                console.log('âœ… å®šæ—¶å™¨å·²æ¸…é™¤');
            }
            
            // ç«‹å³åˆ‡æ¢çŠ¶æ€ï¼ˆå…³é”®ï¼šåœ¨ä»»ä½•æ¸²æŸ“ä¹‹å‰ï¼‰
            replayState.isPlaying = false;
            replayState.isReplayMode = false;
            replayState.currentIndex = 0;
            replayState.currentSubStep = 0;
            console.log('âœ… çŠ¶æ€å·²é‡ç½®');
            
            // æ¸…ç©ºå›æ”¾ç¼“å­˜
            replayState.fullData = null;
            replayState.allDates = [];
            
            // æ›´æ–°æŒ‰é’®
            const btn = document.getElementById('replayBtn');
            btn.textContent = 'â¯ï¸ å›æ”¾';
            btn.classList.remove('bg-red-500', 'hover:bg-red-600');
            btn.classList.add('bg-blue-500', 'hover:bg-blue-600');
            
            // âœ… ç«‹å³é‡ç½®è¿›åº¦æ¡ï¼ˆé˜²æ­¢ç»§ç»­åŠ¨ç”»ï¼‰
            document.getElementById('progressText').textContent = 'ç­‰å¾…å¼€å§‹...';
            document.getElementById('progressPercent').textContent = '0%';
            document.getElementById('progressBar').style.width = '0%';
            
            console.log('ğŸ”„ å›æ”¾ç»“æŸï¼Œæ¢å¤æ­£å¸¸æ¨¡å¼');
            
            // å»¶è¿Ÿ100mså†æ¢å¤è½®è¯¢ï¼Œç¡®ä¿çŠ¶æ€å®Œå…¨åˆ‡æ¢
            setTimeout(() => {
                startPolling();
                console.log('âœ… è½®è¯¢å·²æ¢å¤');
            }, 100);
        }
        
        // åˆå§‹åŒ–å›æ”¾å›¾è¡¨ï¼ˆä½¿ç”¨ä¿å­˜çš„åæ ‡è½´é…ç½®ï¼‰
        function initReplayChart() {
            // ä»å®Œæ•´æ•°æ®ä¸­æå–æ‰€æœ‰æ—¥æœŸ
            const allDatesSet = new Set();
            Object.values(replayState.fullData).forEach(modelData => {
                if (modelData.daily_assets) {
                    modelData.daily_assets.forEach(d => {
                        allDatesSet.add(d.date);
                    });
                }
            });
            
            replayState.allDates = Array.from(allDatesSet).sort();
            
            // åœ¨æœ«å°¾æ·»åŠ 3ä¸ªç©ºç™½æ—¥æœŸï¼ˆä¸æ­£å¸¸æ¨¡å¼ä¿æŒä¸€è‡´ï¼Œé¿å…æ¨ªè½´è·³å˜ï¼‰
            if (replayState.allDates.length > 0) {
                const lastDate = replayState.allDates[replayState.allDates.length - 1];
                const year = parseInt(lastDate.substr(0, 4));
                const month = parseInt(lastDate.substr(4, 2));
                const day = parseInt(lastDate.substr(6, 2));
                
                for (let i = 1; i <= 3; i++) {
                    const nextDate = new Date(year, month - 1, day + i);
                    const nextDateStr = `${nextDate.getFullYear()}${String(nextDate.getMonth() + 1).padStart(2, '0')}${String(nextDate.getDate()).padStart(2, '0')}`;
                    replayState.allDates.push(nextDateStr);
                }
            }
            
            // ç”Ÿæˆå®Œæ•´çš„Xè½´æ ‡ç­¾ï¼ˆåŸºäºfullDataçš„å®Œæ•´æ—¥æœŸèŒƒå›´ + 3ä¸ªç©ºç™½æ—¥æœŸï¼‰
            const xAxisLabels = replayState.allDates.map(date => {
                return `${date.substr(4,2)}-${date.substr(6,2)}`;
            });
            
            // ä½¿ç”¨ä¿å­˜çš„Yè½´é…ç½®ï¼ˆä¿æŒå’Œå›æ”¾å‰ä¸€è‡´ï¼‰
            const yMin = replayState.savedAxisConfig.yMin;
            const yMax = replayState.savedAxisConfig.yMax;
            
            // âœ… å›ºå®šå›¾è¡¨é«˜åº¦
            const chartHeight = 600;
            document.getElementById('chart').style.height = `${chartHeight}px`;
            
            // å›æ”¾æ—¶ä½¿ç”¨å®Œæ•´çš„å›ºå®šXè½´æ ‡ç­¾
            replayState.fixedAxisConfig = {
                xAxisLabels: xAxisLabels,  // ä½¿ç”¨å®Œæ•´æ—¥æœŸèŒƒå›´
                yMin,
                yMax,
                initialCapital: replayState.savedAxisConfig.initialCapital
            };
        }
        
        // æ¸²æŸ“å›æ”¾å¸§ï¼ˆæ”¯æŒæ’å€¼çš„å¹³æ»‘æ’­æ”¾ï¼‰
        function renderReplayFrame(index, subStep) {
            // æ’å€¼æ¯”ä¾‹ (0 åˆ° 1)
            const t = subStep / replayState.interpolationSteps;
            
            // ä¸ºæ¯ä¸ªæ¨¡å‹åˆ›å»ºæ•°æ®æ•°ç»„
            const series = config.models.map(model => {
                const modelData = replayState.fullData[model.id];  // âœ… ä½¿ç”¨idè€Œä¸æ˜¯name
                if (!modelData || !modelData.daily_assets) return null;
                
                // åˆ›å»ºå®Œæ•´é•¿åº¦çš„æ•°ç»„
                const dataPoints = new Array(replayState.allDates.length).fill(null);
                
                // æ‰¾åˆ°å½“å‰æœ€æ–°çš„èµ„äº§å€¼ï¼ˆç”¨äºæ˜¾ç¤ºæ ‡ç­¾ï¼‰
                let latestAssets = 10000;
                let latestDateIndex = -1;
                let currentValue = 10000;  // ç”¨äºæ’å€¼æ˜¾ç¤º
                
                // æ„å»ºæ—¥æœŸåˆ°èµ„äº§çš„æ˜ å°„
                const dateValueMap = {};
                modelData.daily_assets.forEach(d => {
                    dateValueMap[d.date] = d.total_assets;
                });
                
                // å¡«å……æ•°æ®ï¼ˆåŒ…å«æ’å€¼ï¼‰
                for (let i = 0; i <= index; i++) {
                    const date = replayState.allDates[i];
                    const value = dateValueMap[date];
                    
                    if (value !== undefined) {
                        if (i < index) {
                            // å·²å®Œæˆçš„æ•°æ®ç‚¹ï¼Œç›´æ¥ä½¿ç”¨
                            dataPoints[i] = value;
                        } else {
                            // å½“å‰æ­£åœ¨æ’­æ”¾çš„æ•°æ®ç‚¹ï¼Œéœ€è¦æ’å€¼
                            const prevIndex = i - 1;
                            if (prevIndex >= 0 && dateValueMap[replayState.allDates[prevIndex]] !== undefined) {
                                const prevValue = dateValueMap[replayState.allDates[prevIndex]];
                                // çº¿æ€§æ’å€¼
                                dataPoints[i] = prevValue + (value - prevValue) * t;
                                currentValue = dataPoints[i];
                            } else {
                                dataPoints[i] = value * t;
                                currentValue = dataPoints[i];
                            }
                        }
                        
                        if (i >= latestDateIndex) {
                            latestDateIndex = i;
                            latestAssets = dataPoints[i];
                        }
                    }
                }
                
                // âœ… åŠ¨æ€å¡«å……nullå€¼ï¼ˆçº¿æ€§æ’å€¼ï¼‰ï¼Œé¿å…æ–­çº¿
                for (let i = 0; i <= index; i++) {
                    if (dataPoints[i] === null) {
                        // æ‰¾åˆ°å‰ä¸€ä¸ªénullå€¼
                        let prevValue = null;
                        let prevIndex = -1;
                        for (let j = i - 1; j >= 0; j--) {
                            if (dataPoints[j] !== null) {
                                prevValue = dataPoints[j];
                                prevIndex = j;
                                break;
                            }
                        }
                        
                        // æ‰¾åˆ°åä¸€ä¸ªénullå€¼
                        let nextValue = null;
                        let nextIndex = -1;
                        for (let j = i + 1; j <= index; j++) {
                            if (dataPoints[j] !== null) {
                                nextValue = dataPoints[j];
                                nextIndex = j;
                                break;
                            }
                        }
                        
                        // çº¿æ€§æ’å€¼å¡«å……
                        if (prevValue !== null && nextValue !== null) {
                            const ratio = (i - prevIndex) / (nextIndex - prevIndex);
                            dataPoints[i] = prevValue + (nextValue - prevValue) * ratio;
                        } else if (prevValue !== null) {
                            // åªæœ‰å‰å€¼ï¼Œä¿æŒä¸å˜
                            dataPoints[i] = prevValue;
                        } else if (nextValue !== null) {
                            // åªæœ‰åå€¼ï¼Œä½¿ç”¨åå€¼
                            dataPoints[i] = nextValue;
                        }
                    }
                }
                
                // æ›´æ–°èµ„äº§å¡ç‰‡ï¼ˆä½¿ç”¨æ’å€¼åçš„å€¼ï¼‰
                const assetEl = document.getElementById(`asset-${model.name}`);
                const profitEl = document.getElementById(`profit-${model.name}`);
                if (assetEl && profitEl && latestDateIndex >= 0) {
                    assetEl.textContent = `Â¥${Math.round(currentValue).toLocaleString()}`;
                    const initialCapital = config.initial_capital || 10000;
                    const profitPct = ((currentValue - initialCapital) / initialCapital) * 100;
                    profitEl.textContent = `${profitPct >= 0 ? '+' : ''}${profitPct.toFixed(2)}%`;
                    profitEl.className = `text-sm font-medium ${profitPct >= 0 ? 'text-red-600' : 'text-green-600'}`;
                }
                
                return {
                    name: model.name,
                    type: 'line',
                    data: dataPoints,
                    itemStyle: { color: model.color },
                    lineStyle: { width: 2, color: model.color },
                    smooth: true,
                    animation: false,
                    symbol: 'none',
                    zlevel: 0,  // é™ä½æ›²çº¿å±‚çº§
                    z: 1,
                    connectNulls: true,  // è¿æ¥nullå€¼ï¼Œé¿å…æ–­çº¿
                    // æ·»åŠ æœ«ç«¯æ ‡è®°ï¼ˆä½¿ç”¨æ’å€¼åçš„å€¼ï¼‰
                    markPoint: latestDateIndex >= 0 ? {
                        silent: false,
                        animation: false,  // å›æ”¾æ—¶ç¦ç”¨markPointåŠ¨ç”»
                        animationDuration: 0,
                        animationDurationUpdate: 0,
                        emphasis: {
                            scale: 1.2  // æ‚¬åœæ—¶æ”¾å¤§ï¼ˆä¸æ­£å¸¸æ¨¡å¼ä¸€è‡´ï¼‰
                        },
                        data: [
                            // å›¾æ ‡
                            {
                                xAxis: latestDateIndex,
                                yAxis: currentValue,  // ä½¿ç”¨æ’å€¼åçš„å½“å‰å€¼
                                symbol: model.logo ? `image://${model.logo}` : 'circle',
                                symbolSize: model.logo ? [32, 32] : 30,
                                symbolOffset: [0, 0],
                                z: 999,  // å•ç‹¬è®¾ç½®zå±‚çº§
                                itemStyle: {
                                    color: model.logo ? 'transparent' : model.color,
                                    borderColor: model.color,
                                    borderWidth: 3
                                },
                                label: {
                                    show: false
                                }
                            },
                            // é‡‘é¢æ ‡ç­¾
                            {
                                xAxis: latestDateIndex,
                                yAxis: currentValue,  // ä½¿ç”¨æ’å€¼åçš„å½“å‰å€¼
                                symbol: 'rect',
                                symbolSize: [110, 26],
                                symbolOffset: [75, 0],
                                z: 999,  // å•ç‹¬è®¾ç½®zå±‚çº§
                                itemStyle: {
                                    color: model.color,
                                    borderWidth: 0
                                },
                                label: {
                                    show: true,
                                    formatter: `Â¥${Math.round(currentValue).toLocaleString()}`,
                                    color: '#fff',
                                    fontSize: 12,
                                    fontWeight: 'bold',
                                    padding: [2, 8]
                                }
                            }
                        ]
                    } : undefined
                };
            }).filter(s => s !== null);
            
            // âœ… æ·»åŠ ç©ºçš„æ³¢çº¹serieså ä½ï¼ˆä¸æ­£å¸¸æ¨¡å¼ä¿æŒseriesç»“æ„ä¸€è‡´ï¼‰
            const emptyRippleSeries = config.models.map(model => ({
                name: `${model.name}_ripple`,
                type: 'effectScatter',
                data: [],  // ç©ºæ•°æ®ï¼Œä¸æ˜¾ç¤º
                silent: true
            }));
            
            // å®Œå…¨æ›¿æ¢seriesï¼ˆä¿æŒä¸æ­£å¸¸æ¨¡å¼ç›¸åŒçš„seriesç»“æ„ï¼‰
            chart.setOption({
                series: [
                    ...series,
                    ...emptyRippleSeries,  // âœ… æ³¢çº¹å ä½
                    {
                        name: 'åˆå§‹èµ„é‡‘',
                        type: 'line',
                        silent: true,
                        markLine: {
                            silent: true,
                            symbol: 'none',
                            label: {
                                show: true,
                                position: 'insideEndTop',
                                formatter: () => `åˆå§‹: Â¥${replayState.fixedAxisConfig.initialCapital.toLocaleString()}`,
                                color: '#666',
                                fontSize: 11
                            },
                            lineStyle: {
                                color: '#ff9800',
                                type: 'dashed',
                                width: 2
                            },
                            data: [{ yAxis: replayState.fixedAxisConfig.initialCapital }]
                        },
                        data: []
                    }
                ]
            }, {
                notMerge: false,  // âœ… ä½¿ç”¨mergeæ¨¡å¼ï¼Œä¿ç•™markPoint
                lazyUpdate: false,  // ç«‹å³æ›´æ–°
                silent: true  // é™é»˜æ›´æ–°ï¼Œä¸è§¦å‘äº‹ä»¶
            });
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.onload = init;
    </script>
</body>
</html>
